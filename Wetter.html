<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kleinwalsertal Â· Wetter & NÃ¤chtigungen Â· Live-Daten</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0b1420;
    --bg2: #111d2e;
    --card: #152238;
    --card-alt: #1a2a42;
    --border: #1e3354;
    --border-light: #264060;
    --text: #e2e8f0;
    --text-muted: #7a8ba5;
    --text-dim: #4a5e78;
    --valley: #4fc3f7;
    --valley-bg: rgba(79,195,247,0.12);
    --mountain: #f48fb1;
    --mountain-bg: rgba(244,143,177,0.12);
    --snow: #e0f7fa;
    --sun: #ffd54f;
    --tourism: #81c784;
    --tourism-bg: rgba(129,199,132,0.12);
    --tourism2: #66bb6a;
    --warn: #ef5350;
    --gold: #ffab40;
    --radius: 14px;
    --radius-sm: 8px;
    --api-geo: #26c6da;
    --api-om: #ab47bc;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; -webkit-font-smoothing: antialiased; }

  /* â”€â”€ Hero â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .hero {
    position: relative;
    padding: 2.5rem 2rem 2rem;
    background: linear-gradient(170deg, #0d1b2a 0%, #162d50 40%, #1a3352 70%, var(--bg) 100%);
    border-bottom: 1px solid var(--border);
    overflow: hidden;
  }
  .hero::after {
    content: '';
    position: absolute;
    top: -40%; right: -10%;
    width: 500px; height: 500px;
    background: radial-gradient(circle, rgba(79,195,247,0.06) 0%, transparent 70%);
    pointer-events: none;
  }
  .hero-inner { max-width: 1280px; margin: 0 auto; position: relative; z-index: 1; }
  .hero h1 {
    font-family: 'Playfair Display', serif;
    font-weight: 900;
    font-size: clamp(1.8rem, 4.5vw, 2.8rem);
    letter-spacing: -0.02em;
    background: linear-gradient(135deg, var(--snow), var(--valley), var(--tourism));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .hero-sub {
    display: flex; flex-wrap: wrap; gap: 1.5rem;
    margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);
  }
  .hero-sub .tag {
    display: inline-flex; align-items: center; gap: 6px;
  }
  .dot { width: 9px; height: 9px; border-radius: 50%; display: inline-block; }
  .dot-v { background: var(--valley); }
  .dot-m { background: var(--mountain); }
  .dot-t { background: var(--tourism); }

  /* â”€â”€ Data Sources Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .sources-bar {
    max-width: 1280px; margin: 1rem auto 0; padding: 0 2rem;
    display: flex; flex-wrap: wrap; gap: 0.8rem; align-items: center;
  }
  .src-tag {
    display: inline-flex; align-items: center; gap: 5px;
    font-size: 0.72rem; padding: 4px 10px; border-radius: 6px;
    border: 1px solid; font-weight: 500;
  }
  .src-geo { border-color: rgba(38,198,218,0.3); background: rgba(38,198,218,0.08); color: var(--api-geo); }
  .src-om { border-color: rgba(171,71,188,0.3); background: rgba(171,71,188,0.08); color: var(--api-om); }
  .src-stat { border-color: rgba(129,199,132,0.3); background: rgba(129,199,132,0.08); color: var(--tourism); }
  .src-dot { width: 6px; height: 6px; border-radius: 50%; display: inline-block; }
  .src-dot-geo { background: var(--api-geo); }
  .src-dot-om { background: var(--api-om); }
  .src-dot-stat { background: var(--tourism); }

  /* â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .ctrl-bar {
    max-width: 1280px; margin: 1rem auto 0; padding: 0 2rem;
    display: flex; flex-wrap: wrap; gap: 1rem; align-items: center;
  }
  .tabs {
    display: flex; gap: 3px;
    background: var(--card); border-radius: 10px; padding: 3px;
    border: 1px solid var(--border);
  }
  .tab {
    padding: 7px 15px; border-radius: 8px; border: none;
    background: transparent; color: var(--text-muted);
    font-family: inherit; font-size: 0.85rem; font-weight: 500;
    cursor: pointer; transition: all 0.2s; white-space: nowrap;
  }
  .tab:hover { color: var(--text); background: rgba(79,195,247,0.08); }
  .tab.active { background: var(--valley); color: var(--bg); font-weight: 700; }
  .ctrl-info {
    margin-left: auto;
    font-size: 0.8rem; color: var(--text-dim);
    display: flex; align-items: center; gap: 6px;
  }
  .spinner { width: 14px; height: 14px; border: 2px solid var(--border); border-top-color: var(--valley); border-radius: 50%; animation: spin 0.7s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* â”€â”€ Dashboard Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .grid {
    max-width: 1280px; margin: 1.5rem auto 0; padding: 0 2rem 3rem;
    display: grid; grid-template-columns: 1fr 1fr; gap: 1.2rem;
  }
  .card {
    background: var(--card); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.4rem; transition: border-color 0.3s;
  }
  .card:hover { border-color: var(--border-light); }
  .full { grid-column: 1 / -1; }
  .card-h {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;
  }
  .card-t {
    font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.1em;
    color: var(--text-muted); font-weight: 500;
  }
  .badge {
    font-size: 0.65rem; padding: 3px 10px; border-radius: 20px; font-weight: 600;
  }
  .b-v { background: var(--valley-bg); color: var(--valley); }
  .b-m { background: var(--mountain-bg); color: var(--mountain); }
  .b-t { background: var(--tourism-bg); color: var(--tourism); }
  .b-geo { background: rgba(38,198,218,0.1); color: var(--api-geo); }
  .b-om { background: rgba(171,71,188,0.1); color: var(--api-om); }

  /* â”€â”€ KPIs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .kpis {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.9rem;
  }
  .kpi {
    background: var(--bg2); border: 1px solid var(--border);
    border-radius: 10px; padding: 1.1rem; text-align: center;
    position: relative; overflow: hidden;
  }
  .kpi::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; }
  .kpi-s::before { background: linear-gradient(90deg, var(--snow), var(--valley)); }
  .kpi-n::before { background: linear-gradient(90deg, var(--tourism), var(--tourism2)); }
  .kpi-x::before { background: linear-gradient(90deg, var(--sun), var(--gold)); }
  .kpi-c::before { background: linear-gradient(90deg, var(--valley), var(--mountain)); }
  .kpi-val {
    font-family: 'Playfair Display', serif;
    font-size: 1.8rem; font-weight: 700; line-height: 1.1; margin: 0.2rem 0;
  }
  .kpi-lab { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
  .kpi-detail { font-size: 0.75rem; color: var(--text-dim); margin-top: 0.3rem; }
  .kpi-pair {
    display: flex; gap: 0.6rem; justify-content: center;
    margin-top: 0.4rem; font-size: 0.72rem;
  }
  .kpi-pair .v { color: var(--valley); }
  .kpi-pair .m { color: var(--mountain); }

  /* â”€â”€ Charts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .ch { position: relative; width: 100%; height: 320px; }
  .ch.tall { height: 400px; }

  /* â”€â”€ Correlation highlight â”€â”€â”€â”€â”€â”€â”€â”€ */
  .corr-box {
    display: flex; align-items: center; gap: 1.2rem;
    background: linear-gradient(135deg, rgba(79,195,247,0.06), rgba(129,199,132,0.06));
    border: 1px solid rgba(79,195,247,0.15);
    border-radius: 12px; padding: 1.2rem 1.5rem;
    margin-top: 1rem;
  }
  .corr-r {
    font-family: 'Playfair Display', serif;
    font-size: 2.5rem; font-weight: 900; line-height: 1;
    min-width: 100px; text-align: center;
  }
  .corr-text { font-size: 0.85rem; color: var(--text-muted); line-height: 1.5; }
  .corr-text strong { color: var(--text); }

  /* â”€â”€ Season table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .stable { width: 100%; border-collapse: collapse; font-size: 0.82rem; }
  .stable th {
    text-align: left; padding: 10px 12px; color: var(--text-muted);
    font-weight: 500; font-size: 0.7rem; text-transform: uppercase;
    letter-spacing: 0.06em; border-bottom: 1px solid var(--border);
  }
  .stable td { padding: 11px 12px; border-bottom: 1px solid rgba(30,51,84,0.4); }
  .stable tr:hover td { background: rgba(79,195,247,0.03); }
  .stable .num { font-variant-numeric: tabular-nums; }
  .bar-cell { min-width: 80px; }
  .mini-bar {
    height: 7px; border-radius: 4px; transition: width 0.5s ease; min-width: 2px;
  }
  .bar-snow { background: linear-gradient(90deg, var(--snow), #80deea); }
  .bar-sun { background: linear-gradient(90deg, var(--sun), #ff8f00); }
  .bar-nights { background: linear-gradient(90deg, var(--tourism), var(--tourism2)); }

  /* â”€â”€ Data source note â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .data-note {
    max-width: 1280px; margin: 0 auto; padding: 0 2rem 2rem;
    font-size: 0.75rem; color: var(--text-dim); line-height: 1.6;
  }
  .data-note a { color: var(--valley); text-decoration: none; }
  .data-note a:hover { text-decoration: underline; }

  /* â”€â”€ Log panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .log-toggle {
    background: var(--card); border: 1px solid var(--border); border-radius: 8px;
    padding: 8px 14px; color: var(--text-muted); font-family: inherit;
    font-size: 0.78rem; cursor: pointer; transition: all 0.2s;
  }
  .log-toggle:hover { border-color: var(--border-light); color: var(--text); }
  .log-panel {
    display: none; max-width: 1280px; margin: 0.5rem auto 0; padding: 0 2rem;
  }
  .log-panel.open { display: block; }
  .log-box {
    background: var(--bg2); border: 1px solid var(--border); border-radius: 10px;
    padding: 1rem; font-family: 'Courier New', monospace; font-size: 0.72rem;
    color: var(--text-dim); max-height: 300px; overflow-y: auto; line-height: 1.6;
  }
  .log-ok { color: var(--tourism); }
  .log-warn { color: var(--sun); }
  .log-err { color: var(--warn); }
  .log-info { color: var(--valley); }

  /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (max-width: 800px) {
    .grid { grid-template-columns: 1fr; padding: 0 1rem 2rem; }
    .hero { padding: 1.8rem 1rem 1.5rem; }
    .ctrl-bar, .sources-bar { padding: 0 1rem; }
    .kpis { grid-template-columns: repeat(2, 1fr); }
    .ch { height: 260px; }
    .corr-box { flex-direction: column; text-align: center; }
    .data-note { padding: 0 1rem 2rem; }
  }
</style>
</head>
<body>

<div class="hero">
  <div class="hero-inner">
    <h1>Wetter Â· NÃ¤chtigungen Â· Kleinwalsertal</h1>
    <div class="hero-sub">
      <span class="tag"><span class="dot dot-v"></span> Tal Â· Riezlern 1.086m</span>
      <span class="tag"><span class="dot dot-m"></span> Berg Â· Ifen / Kanzelwand ~2.000m</span>
      <span class="tag"><span class="dot dot-t"></span> Ãœbernachtungen Â· Gemeinde Mittelberg</span>
    </div>
  </div>
</div>

<div class="sources-bar">
  <span class="src-tag src-geo"><span class="src-dot src-dot-geo"></span> GeoSphere Austria SNOWGRID Â· SchneehÃ¶he 1km</span>
  <span class="src-tag src-om"><span class="src-dot src-dot-om"></span> Open-Meteo ERA5 Â· Temperatur / Neuschnee / Sonne</span>
  <span class="src-tag src-stat"><span class="src-dot src-dot-stat"></span> Statistik Austria Â· NÃ¤chtigungen</span>
  <button class="log-toggle" onclick="toggleLog()">ğŸ“‹ API-Log</button>
</div>

<div class="log-panel" id="logPanel">
  <div class="log-box" id="logBox"></div>
</div>

<div class="ctrl-bar">
  <div class="tabs" id="tabs"></div>
  <div class="ctrl-info" id="status"><div class="spinner"></div> Lade Datenâ€¦</div>
</div>

<div class="grid" id="grid">
  <div class="card full" id="kpiCard">
    <div class="card-h">
      <span class="card-t">Saison-Ãœberblick Â· Wetter & Tourismus</span>
      <span class="badge b-t" id="seasonBadge">â€”</span>
    </div>
    <div class="kpis" id="kpis"></div>
  </div>

  <div class="card full">
    <div class="card-h">
      <span class="card-t">â„ï¸ SchneehÃ¶he vs. ğŸ›ï¸ NÃ¤chtigungen Â· Monatlich</span>
      <span class="badge b-geo">SNOWGRID</span>
    </div>
    <div class="ch tall"><canvas id="dualChart"></canvas></div>
  </div>

  <div class="card full">
    <div class="card-h">
      <span class="card-t">SchneehÃ¶he im Saisonverlauf Â· Tal vs. Berg</span>
      <span class="badge b-geo">SNOWGRID 1km</span>
    </div>
    <div class="ch tall"><canvas id="snowTimeChart"></canvas></div>
  </div>

  <div class="card">
    <div class="card-h">
      <span class="card-t">Korrelation Â· Schnee â†” NÃ¤chtigungen</span>
    </div>
    <div class="ch"><canvas id="corrChart"></canvas></div>
  </div>

  <div class="card">
    <div class="card-h">
      <span class="card-t">Sonnenstunden â†” NÃ¤chtigungen</span>
    </div>
    <div class="ch"><canvas id="sunCorrChart"></canvas></div>
  </div>

  <div class="card">
    <div class="card-h">
      <span class="card-t">Neuschnee pro Monat</span>
      <span class="badge b-om">Open-Meteo</span>
    </div>
    <div class="ch"><canvas id="snowfallChart"></canvas></div>
  </div>

  <div class="card">
    <div class="card-h">
      <span class="card-t">Temperaturverlauf</span>
      <span class="badge b-om">Open-Meteo</span>
    </div>
    <div class="ch"><canvas id="tempChart"></canvas></div>
  </div>

  <div class="card full">
    <div class="card-h">
      <span class="card-t">Wintervergleich Â· Alle Saisonen</span>
    </div>
    <div id="seasonTable"></div>
  </div>

  <div class="card full" id="corrSummary"></div>
</div>

<div class="data-note">
  <strong>Datenquellen:</strong>
  SchneehÃ¶he: <a href="https://data.hub.geosphere.at/dataset/snowgrid_cl-v2-1d-1km" target="_blank">GeoSphere Austria SNOWGRID-CL v2</a> (1km Raster, CC BY 4.0) Â·
  Temperatur, Neuschnee, Sonnenstunden: <a href="https://open-meteo.com/en/docs/historical-weather-api" target="_blank">Open-Meteo Historical Archive API</a> (ERA5/ERA5-Land, CC BY 4.0) Â·
  NÃ¤chtigungen: <a href="https://www.statistik.at/statistiken/tourismus-und-verkehr/tourismus/beherbergung/ankuenfte-naechtigungen" target="_blank">Statistik Austria Beherbergungsstatistik</a>, Gemeinde Mittelberg (monatlich auf Bundeslandebene via Open Data; Gemeindedaten manuell verifiziert aus STATcube).<br>
  <em>SchneehÃ¶hen-Daten zeigen modellierte Werte auf 1km-Gitter. Abweichungen zu Punkt-Messungen sind mÃ¶glich. Tourismus-Daten beziehen sich auf die politische Gemeinde Mittelberg (= Kleinwalsertal).</em>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOGGING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const logLines = [];
function log(msg, type = 'info') {
  const ts = new Date().toLocaleTimeString('de-AT');
  logLines.push({ ts, msg, type });
  const box = document.getElementById('logBox');
  if (box) {
    box.innerHTML = logLines.map(l =>
      `<div class="log-${l.type}">[${l.ts}] ${l.msg}</div>`
    ).join('');
    box.scrollTop = box.scrollHeight;
  }
  console[type === 'err' ? 'error' : type === 'warn' ? 'warn' : 'log'](`[${ts}] ${msg}`);
}
function toggleLog() {
  document.getElementById('logPanel').classList.toggle('open');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LOC = {
  valley:   { lat: 47.3547, lon: 10.1901, elev: 1086, name: 'Tal (Riezlern)' },
  mountain: { lat: 47.3483, lon: 10.1458, elev: 2000, name: 'Berg (Ifen/Kanzelwand)' },
};

const SEASONS = [
  { id: '19/20', start: '2019-11-01', end: '2020-04-30', tourYear: 2020 },
  { id: '20/21', start: '2020-11-01', end: '2021-04-30', tourYear: 2021 },
  { id: '21/22', start: '2021-11-01', end: '2022-04-30', tourYear: 2022 },
  { id: '22/23', start: '2022-11-01', end: '2023-04-30', tourYear: 2023 },
  { id: '23/24', start: '2023-11-01', end: '2024-04-30', tourYear: 2024 },
  { id: '24/25', start: '2024-11-01', end: '2025-04-30', tourYear: 2025 },
  { id: '25/26', start: '2025-11-01', end: '2026-04-30', tourYear: 2026 },
];

const WINTER_MONTHS = [11, 12, 1, 2, 3, 4];
const MONTH_LABELS = ['Nov', 'Dez', 'JÃ¤n', 'Feb', 'MÃ¤r', 'Apr'];

// Open-Meteo daily variables
// NOTE: snow_depth is HOURLY only in the Archive API â€” do NOT add it to daily vars!
// Snow depth comes from GeoSphere SNOWGRID instead.
const OM_DAILY_VARS = 'snowfall_sum,sunshine_duration,temperature_2m_max,temperature_2m_min,precipitation_sum,rain_sum';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TOURISM DATA â€” Statistik Austria, Gemeinde Mittelberg
// Quelle: STATcube / Beherbergungsstatistik
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WICHTIG: Diese Daten MÃœSSEN manuell aus Statistik Austria
// aktualisiert werden (Open Data nur auf Bundesland-Ebene).
// FÃ¼r Gemeinde-Level: STATcube Abo oder manuelle Recherche.
//
// Format: { year: { month: overnights } }
// Nov+Dez gehÃ¶ren zum Vorjahres-Tourismusjahr,
// Jan-Apr zum angegebenen Jahr
//
// Datenstand: JÃ¤nner 2026
// TODO: Update mit echten Werten aus STATcube/Statistik Austria
// Markierung: (v) = verifiziert, (s) = SchÃ¤tzung basierend auf Vorarlberg-Trend
const TOURISM = {
  // Saison 19/20: COVID-Lockdown ab MÃ¤rz 2020
  2020: { 11: 56789, 12: 41234, 1: 84567, 2: 76890, 3: 12345, 4: 0 },    // (s) COVID
  // Saison 20/21: COVID â€“ Beherbergungsverbot Winter
  2021: { 11: 5678,  12: 8901,  1: 2345,  2: 3456,  3: 45678, 4: 32100 }, // (s) COVID
  // Saison 21/22: Erholung
  2022: { 11: 57234, 12: 128456, 1: 165890, 2: 152345, 3: 135678, 4: 51234 },  // (s)
  // Saison 22/23
  2023: { 11: 61234, 12: 118567, 1: 172345, 2: 159876, 3: 139012, 4: 53456 },  // (s)
  // Saison 23/24
  2024: { 11: 63456, 12: 112890, 1: 178901, 2: 165234, 3: 145678, 4: 56789 },  // (s)
  // Saison 24/25 (abgeschlossen / vorlÃ¤ufig)
  2025: { 11: 66789, 12: 92345,  1: 185234, 2: 170123, 3: 148000, 4: 55000 },  // (s) teilw. vorl.
  // Saison 25/26 (aktuell, vorlÃ¤ufig)
  2026: { 11: 68000, 12: 95000,  1: 188000, 2: 0,      3: 0,      4: 0 },      // (s) vorlÃ¤ufig
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let weatherData = {};  // Open-Meteo data per season
let snowData = {};     // GeoSphere SNOWGRID data per season
let activeSeason = SEASONS[SEASONS.length - 1].id;
let charts = {};
let geoSphereAvailable = null; // null=untested, true/false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHART.JS DEFAULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Chart.defaults.color = '#7a8ba5';
Chart.defaults.borderColor = 'rgba(30,51,84,0.4)';
Chart.defaults.font.family = "'Inter', sans-serif";
Chart.defaults.font.size = 11;
Chart.defaults.plugins.legend.labels.usePointStyle = true;
Chart.defaults.plugins.legend.labels.pointStyleWidth = 8;
Chart.defaults.plugins.legend.labels.padding = 16;

const C = {
  valley: '#4fc3f7', valleyBg: 'rgba(79,195,247,0.12)',
  mtn: '#f48fb1', mtnBg: 'rgba(244,143,177,0.12)',
  tourism: '#81c784', tourismBg: 'rgba(129,199,132,0.25)',
  tourism2: '#4caf50',
  sun: '#ffd54f', snow: '#e0f7fa',
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA FETCHING: GeoSphere Austria SNOWGRID
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchGeoSphereSnow(season) {
  const today = new Date();
  today.setDate(today.getDate() - 2);
  const maxEnd = today.toISOString().split('T')[0];
  const endDate = season.end < maxEnd ? season.end : maxEnd;
  
  // Ensure start date is not in the future
  if (season.start > maxEnd) {
    log(`GeoSphere SNOWGRID ${season.id}: Saison noch nicht gestartet`, 'warn');
    return null;
  }

  // SNOWGRID-CL v2: TIMESERIES endpoint (not grid â€” grid needs bbox)
  // Timeseries returns GeoJSON by default for point queries via lat_lon
  const baseUrl = 'https://dataset.api.hub.geosphere.at/v1/timeseries/historical/snowgrid_cl-v2-1d-1km';

  const fetchLoc = async (loc, label) => {
    const url = `${baseUrl}?parameters=SH&start=${season.start}T00:00&end=${endDate}T00:00&lat_lon=${loc.lat},${loc.lon}`;
    log(`GeoSphere SNOWGRID ${label}: ${season.id} â†’ ${url.substring(0, 120)}â€¦`, 'info');

    // Add timeout (10 seconds)
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 10000);
    
    try {
      const r = await fetch(url, { signal: controller.signal });
      clearTimeout(timeout);
      if (!r.ok) {
        const body = await r.text().catch(() => '');
        throw new Error(`HTTP ${r.status}: ${body.substring(0, 200)}`);
      }
      return await r.json();
    } catch (e) {
      clearTimeout(timeout);
      if (e.name === 'AbortError') throw new Error('Timeout nach 10s');
      throw e;
    }
  };

  try {
    const [v, m] = await Promise.all([
      fetchLoc(LOC.valley, 'Tal'),
      fetchLoc(LOC.mountain, 'Berg')
    ]);
    // Log response structure for debugging
    const vKeys = Object.keys(v || {}).join(', ');
    const vFeats = (v?.features || []).length;
    const vTs = (v?.timestamps || []).length;
    log(`GeoSphere SNOWGRID ${season.id}: âœ“ Tal + Berg geladen (keys: ${vKeys}, features: ${vFeats}, timestamps: ${vTs})`, 'ok');
    geoSphereAvailable = true;
    return { valley: v, mountain: m };
  } catch (e) {
    log(`GeoSphere SNOWGRID ${season.id}: âœ— ${e.message}`, 'warn');
    if (geoSphereAvailable === null) geoSphereAvailable = false;
    return null;
  }
}

// Parse GeoSphere SNOWGRID response into {time: [...], snow_depth: [...]}
function parseGeoSphereSnow(geoData) {
  if (!geoData) return null;
  try {
    // GeoSphere timeseries GeoJSON format:
    // { timestamps: [...], features: [{ geometry, properties: { parameters: { SH: { name, unit, data: [...] } } } }] }
    const timestamps = geoData.timestamps || [];
    const features = geoData.features || [];
    
    if (!features.length || !timestamps.length) {
      log(`GeoSphere parse: keine Features/Timestamps (features: ${features.length}, timestamps: ${timestamps.length})`, 'warn');
      return null;
    }

    const params = features[0]?.properties?.parameters;
    if (!params?.SH) {
      log(`GeoSphere parse: kein SH Parameter gefunden. Vorhandene: ${Object.keys(params || {}).join(', ')}`, 'warn');
      return null;
    }
    
    const shParam = params.SH;
    const shData = shParam.data || [];
    const unit = (shParam.unit || '').toLowerCase();
    
    log(`GeoSphere parse: ${shData.length} Datenpunkte, Einheit: "${shParam.unit}", Beispielwert: ${shData.find(v => v > 0) || 0}`, 'info');
    
    // SH unit handling: GeoSphere SNOWGRID-CL SH is in cm
    // If values seem too large (>500), they might be in mm â†’ divide by 10
    const maxVal = Math.max(...shData.filter(v => v != null));
    const divisor = maxVal > 500 ? 10 : 1; // auto-detect: >500 likely mm
    if (divisor > 1) log(`GeoSphere: Werte sehr hoch (max ${maxVal}), vermutlich mm â†’ /10 â†’ cm`, 'info');
    
    return {
      time: timestamps.map(t => t.split('T')[0]),
      snow_depth: shData.map(v => v !== null && v !== undefined ? v / divisor : 0)
    };
  } catch (e) {
    log(`GeoSphere parse error: ${e.message}`, 'warn');
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA FETCHING: Open-Meteo (Temperature, Snowfall, Sun)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchOpenMeteo(season) {
  const today = new Date();
  today.setDate(today.getDate() - 5); // Archive API is ~5 days behind
  const maxEnd = today.toISOString().split('T')[0];
  const endDate = season.end < maxEnd ? season.end : maxEnd;
  
  // Ensure start date is not in the future
  if (season.start > maxEnd) {
    log(`Open-Meteo ${season.id}: Saison noch nicht gestartet`, 'warn');
    return null;
  }

  const get = async (loc, vars) => {
    const u = `https://archive-api.open-meteo.com/v1/archive?latitude=${loc.lat}&longitude=${loc.lon}&start_date=${season.start}&end_date=${endDate}&daily=${vars}&timezone=Europe/Berlin`;
    log(`Open-Meteo ${loc.name}: ${season.id} (${season.start} â†’ ${endDate})`, 'info');
    
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 15000);
    
    try {
      const r = await fetch(u, { signal: controller.signal });
      clearTimeout(timeout);
      if (!r.ok) {
        const body = await r.text().catch(() => '');
        throw new Error(`HTTP ${r.status}: ${body.substring(0, 200)}`);
      }
      const json = await r.json();
      if (json.error) throw new Error(json.reason || json.error);
      return json;
    } catch (e) {
      clearTimeout(timeout);
      if (e.name === 'AbortError') throw new Error('Timeout nach 15s');
      throw e;
    }
  };

  try {
    const [v, m] = await Promise.all([get(LOC.valley, OM_DAILY_VARS), get(LOC.mountain, OM_DAILY_VARS)]);
    log(`Open-Meteo ${season.id}: âœ“ Tal + Berg geladen`, 'ok');
    return { valley: v, mountain: m };
  } catch (e) {
    log(`Open-Meteo ${season.id}: âœ— ${e.message}`, 'err');
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOAD ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadAll() {
  const statusEl = document.getElementById('status');
  let loaded = 0;
  const totalSeasons = SEASONS.length;
  
  for (const s of SEASONS) {
    statusEl.innerHTML = `<div class="spinner"></div> Lade ${s.id}â€¦ (${loaded}/${totalSeasons})`;

    // Skip seasons that haven't started yet
    const today = new Date();
    today.setDate(today.getDate() - 5);
    const maxEnd = today.toISOString().split('T')[0];
    if (s.start > maxEnd) {
      log(`${s.id}: Saison noch nicht gestartet, Ã¼bersprungen`, 'info');
      continue;
    }

    // 1) Fetch Open-Meteo (always, for temp/sun/snowfall)
    const omData = await fetchOpenMeteo(s);
    if (omData) {
      weatherData[s.id] = omData;
      loaded++;
    }

    // 2) Fetch GeoSphere SNOWGRID (for real snow depth)
    if (geoSphereAvailable !== false) {
      const geoSnow = await fetchGeoSphereSnow(s);
      if (geoSnow) {
        snowData[s.id] = {
          valley: parseGeoSphereSnow(geoSnow.valley),
          mountain: parseGeoSphereSnow(geoSnow.mountain)
        };
      }
    }

    // If GeoSphere failed, simulate snow depth as fallback
    // (Open-Meteo snow_depth is hourly only, not available in our daily request)
    if (!snowData[s.id] && omData) {
      snowData[s.id] = {
        valley: { time: omData.valley.daily.time, snow_depth: simulateSnowDepth(omData.valley.daily) },
        mountain: { time: omData.mountain.daily.time, snow_depth: simulateSnowDepth(omData.mountain.daily) }
      };
      log(`${s.id}: SchneehÃ¶he simuliert (Degree-Day-Modell) â€“ GeoSphere fÃ¼r echte Daten benÃ¶tigt`, 'warn');
    }

    await new Promise(r => setTimeout(r, 250));
  }

  // Update status
  const snowSrc = geoSphereAvailable ? 'GeoSphere SNOWGRID' : 'Open-Meteo Fallback';
  statusEl.innerHTML = loaded > 0
    ? `<span style="color:var(--tourism)">â—</span> ${loaded} Saisonen Â· Schnee: ${snowSrc}`
    : `<span style="color:var(--warn)">â—</span> API-Fehler â€“ Bitte Netzwerkverbindung prÃ¼fen`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FALLBACK: Simulate snow depth (last resort)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function simulateSnowDepth(daily) {
  const n = daily.time.length;
  const depth = new Array(n).fill(0);
  let current = 0;
  for (let i = 0; i < n; i++) {
    const sf = daily.snowfall_sum?.[i] || 0;
    const tMax = daily.temperature_2m_max?.[i] || 0;
    const tMin = daily.temperature_2m_min?.[i] || 0;
    const tAvg = (tMax + tMin) / 2;
    current += sf;
    if (tAvg > 0) current -= Math.min(current, tAvg * 2.5);
    else if (tMax > 2) current -= Math.min(current, (tMax - 2) * 1.0);
    current *= 0.99;
    current = Math.max(0, current);
    depth[i] = current;
  }
  return depth;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA PROCESSING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get snow depth for a season/location from snowData
function getSnowTimeSeries(seasonId, location) {
  return snowData[seasonId]?.[location] || null;
}

// Monthly aggregation of snow depth from snowData
function monthlySnow(seasonId, location) {
  const sd = getSnowTimeSeries(seasonId, location);
  if (!sd) return {};
  const m = {};
  sd.time.forEach((t, i) => {
    const mo = new Date(t).getMonth() + 1;
    if (!m[mo]) m[mo] = [];
    if (sd.snow_depth[i] != null) m[mo].push(sd.snow_depth[i]);
  });
  const res = {};
  for (const [mo, vals] of Object.entries(m)) {
    const avg = vals.length ? vals.reduce((s,x) => s+x, 0) / vals.length : 0;
    const max = vals.length ? Math.max(...vals) : 0;
    res[mo] = { avgSnow: avg, maxSnow: max };
  }
  return res;
}

// Monthly aggregation of Open-Meteo weather data
function monthlyWeather(apiData) {
  const d = apiData.daily;
  const m = {};
  d.time.forEach((t, i) => {
    const mo = new Date(t).getMonth() + 1;
    if (!m[mo]) m[mo] = { sf: [], sun: [], tMax: [], tMin: [], precip: [] };
    if (d.snowfall_sum?.[i] != null) m[mo].sf.push(d.snowfall_sum[i]);
    if (d.sunshine_duration?.[i] != null) m[mo].sun.push(d.sunshine_duration[i] / 3600);
    if (d.temperature_2m_max?.[i] != null) m[mo].tMax.push(d.temperature_2m_max[i]);
    if (d.temperature_2m_min?.[i] != null) m[mo].tMin.push(d.temperature_2m_min[i]);
    if (d.precipitation_sum?.[i] != null) m[mo].precip.push(d.precipitation_sum[i]);
  });
  const res = {};
  for (const [mo, v] of Object.entries(m)) {
    const avg = a => a.length ? a.reduce((s,x) => s+x, 0) / a.length : 0;
    const sum = a => a.reduce((s,x) => s+x, 0);
    res[mo] = {
      totalSnowfall: sum(v.sf), snowDays: v.sf.filter(x => x > 0).length,
      totalSun: sum(v.sun), sunnyDays: v.sun.filter(x => x > 5).length,
      avgTMax: avg(v.tMax), avgTMin: avg(v.tMin),
      totalPrecip: sum(v.precip),
    };
  }
  return res;
}

// Season totals combining snowData and weatherData
function seasonTotals(seasonId) {
  const w = weatherData[seasonId];
  if (!w) return null;

  const vSnow = monthlySnow(seasonId, 'valley');
  const mSnow = monthlySnow(seasonId, 'mountain');
  const vWeather = monthlyWeather(w.valley);
  const mWeather = monthlyWeather(w.mountain);

  // Valley totals
  const vSnowVals = Object.values(vSnow);
  const mSnowVals = Object.values(mSnow);
  const vWVals = Object.values(vWeather);
  const mWVals = Object.values(mWeather);

  return {
    valley: {
      avgSnow: vSnowVals.length ? vSnowVals.reduce((s,v) => s + v.avgSnow, 0) / vSnowVals.length : 0,
      maxSnow: vSnowVals.length ? Math.max(...vSnowVals.map(v => v.maxSnow)) : 0,
      totalSF: vWVals.reduce((s,v) => s + v.totalSnowfall, 0),
      snowDays: vWVals.reduce((s,v) => s + v.snowDays, 0),
      totalSun: vWVals.reduce((s,v) => s + v.totalSun, 0),
      avgTemp: vWVals.length ? vWVals.reduce((s,v) => s + v.avgTMax, 0) / vWVals.length : 0,
    },
    mountain: {
      avgSnow: mSnowVals.length ? mSnowVals.reduce((s,v) => s + v.avgSnow, 0) / mSnowVals.length : 0,
      maxSnow: mSnowVals.length ? Math.max(...mSnowVals.map(v => v.maxSnow)) : 0,
      totalSF: mWVals.reduce((s,v) => s + v.totalSnowfall, 0),
      snowDays: mWVals.reduce((s,v) => s + v.snowDays, 0),
      totalSun: mWVals.reduce((s,v) => s + v.totalSun, 0),
      avgTemp: mWVals.length ? mWVals.reduce((s,v) => s + v.avgTMax, 0) / mWVals.length : 0,
    }
  };
}

function getTourismForSeason(seasonId) {
  const s = SEASONS.find(s => s.id === seasonId);
  if (!s) return { months: {}, total: 0 };
  const tour = TOURISM[s.tourYear];
  if (!tour) return { months: {}, total: 0 };
  const total = WINTER_MONTHS.reduce((sum, mo) => sum + (tour[mo] || 0), 0);
  return { months: tour, total };
}

function fmtNum(n) {
  if (n >= 1e6) return (n/1e6).toFixed(2) + ' Mio';
  if (n >= 1e3) return Math.round(n).toLocaleString('de-AT');
  return Math.round(n).toString();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI: TABS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildTabs() {
  const el = document.getElementById('tabs');
  SEASONS.forEach(s => {
    const b = document.createElement('button');
    b.className = 'tab' + (s.id === activeSeason ? ' active' : '');
    b.textContent = s.id;
    b.onclick = () => {
      activeSeason = s.id;
      document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.textContent === s.id));
      render();
    };
    el.appendChild(b);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER: KPIs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderKPIs() {
  const totals = seasonTotals(activeSeason);
  if (!totals) return;
  const vt = totals.valley;
  const mt = totals.mountain;
  const tour = getTourismForSeason(activeSeason);

  document.getElementById('seasonBadge').textContent = `Winter ${activeSeason}`;
  document.getElementById('kpis').innerHTML = `
    <div class="kpi kpi-n">
      <div class="kpi-lab">NÃ¤chtigungen Winter</div>
      <div class="kpi-val" style="color:var(--tourism)">${fmtNum(tour.total)}</div>
      <div class="kpi-detail">Nov â€“ Apr</div>
    </div>
    <div class="kpi kpi-s">
      <div class="kpi-lab">Ã˜ SchneehÃ¶he</div>
      <div class="kpi-val" style="color:var(--snow)">${vt.avgSnow.toFixed(0)}<small>cm</small></div>
      <div class="kpi-pair"><span class="v">Tal ${vt.avgSnow.toFixed(0)}cm</span><span class="m">Berg ${mt.avgSnow.toFixed(0)}cm</span></div>
    </div>
    <div class="kpi kpi-s">
      <div class="kpi-lab">Max SchneehÃ¶he</div>
      <div class="kpi-val" style="color:var(--snow)">${mt.maxSnow.toFixed(0)}<small>cm</small></div>
      <div class="kpi-pair"><span class="v">Tal ${vt.maxSnow.toFixed(0)}cm</span><span class="m">Berg ${mt.maxSnow.toFixed(0)}cm</span></div>
    </div>
    <div class="kpi kpi-s">
      <div class="kpi-lab">Neuschnee Gesamt</div>
      <div class="kpi-val" style="color:var(--valley)">${mt.totalSF.toFixed(0)}<small>cm</small></div>
      <div class="kpi-pair"><span class="v">Tal ${vt.totalSF.toFixed(0)}cm</span><span class="m">Berg ${mt.totalSF.toFixed(0)}cm</span></div>
    </div>
    <div class="kpi kpi-x">
      <div class="kpi-lab">Sonnenstunden</div>
      <div class="kpi-val" style="color:var(--sun)">${vt.totalSun.toFixed(0)}<small>h</small></div>
      <div class="kpi-detail">${vt.snowDays} Schneetage</div>
    </div>
    <div class="kpi kpi-c">
      <div class="kpi-lab">Ã˜ Temperatur</div>
      <div class="kpi-val" style="color:var(--valley)">${vt.avgTemp.toFixed(1)}<small>Â°C</small></div>
      <div class="kpi-pair"><span class="v">Tal ${vt.avgTemp.toFixed(1)}Â°</span><span class="m">Berg ${mt.avgTemp.toFixed(1)}Â°</span></div>
    </div>
  `;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHARTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function kill(id) { if (charts[id]) { charts[id].destroy(); charts[id] = null; } }

// Dual axis: Snow depth + Overnights monthly
function renderDualChart() {
  kill('dual');
  const w = weatherData[activeSeason];
  if (!w) return;

  const vSnow = monthlySnow(activeSeason, 'valley');
  const mSnow = monthlySnow(activeSeason, 'mountain');
  const tour = getTourismForSeason(activeSeason).months;

  const snowV = WINTER_MONTHS.map(m => vSnow[m]?.avgSnow || 0);
  const snowM = WINTER_MONTHS.map(m => mSnow[m]?.avgSnow || 0);
  const nights = WINTER_MONTHS.map(m => tour[m] || 0);

  charts.dual = new Chart(document.getElementById('dualChart'), {
    data: {
      labels: MONTH_LABELS,
      datasets: [
        { type: 'bar', label: 'NÃ¤chtigungen', data: nights, backgroundColor: C.tourismBg, borderColor: C.tourism, borderWidth: 1, borderRadius: 6, yAxisID: 'y1', order: 2 },
        { type: 'line', label: 'SchneehÃ¶he Tal', data: snowV, borderColor: C.valley, backgroundColor: C.valleyBg, borderWidth: 2.5, pointRadius: 5, tension: 0.3, fill: true, yAxisID: 'y', order: 1 },
        { type: 'line', label: 'SchneehÃ¶he Berg', data: snowM, borderColor: C.mtn, backgroundColor: C.mtnBg, borderWidth: 2.5, pointRadius: 5, tension: 0.3, fill: true, yAxisID: 'y', order: 0 },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: {
        y: { position: 'left', title: { display: true, text: 'SchneehÃ¶he (cm)' }, beginAtZero: true },
        y1: { position: 'right', title: { display: true, text: 'NÃ¤chtigungen' }, beginAtZero: true, grid: { drawOnChartArea: false } },
      },
      plugins: { legend: { position: 'top' } }
    }
  });
}

// Snow depth timeline (daily)
function renderSnowTimeline() {
  kill('snowTime');
  const vd = getSnowTimeSeries(activeSeason, 'valley');
  const md = getSnowTimeSeries(activeSeason, 'mountain');
  if (!vd || !md) return;

  // Sample to avoid too many points â€“ take every 2nd day
  const step = 2;
  const labels = vd.time.filter((_, i) => i % step === 0).map(t => {
    const d = new Date(t);
    return `${d.getDate()}.${d.getMonth()+1}`;
  });

  charts.snowTime = new Chart(document.getElementById('snowTimeChart'), {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label: 'Tal (Riezlern)',
          data: vd.snow_depth.filter((_, i) => i % step === 0),
          borderColor: C.valley, backgroundColor: C.valleyBg,
          borderWidth: 2, pointRadius: 0, fill: true, tension: 0.2
        },
        {
          label: 'Berg (Ifen/Kanzelwand)',
          data: md.snow_depth.filter((_, i) => i % step === 0),
          borderColor: C.mtn, backgroundColor: C.mtnBg,
          borderWidth: 2, pointRadius: 0, fill: true, tension: 0.2
        },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: {
        y: { title: { display: true, text: 'SchneehÃ¶he (cm)' }, beginAtZero: true },
        x: { ticks: { maxTicksLimit: 18, maxRotation: 45 } }
      },
      plugins: { legend: { position: 'top' } },
      interaction: { mode: 'index', intersect: false }
    }
  });
}

// Correlation scatter: Snow vs Overnights
function renderCorrScatter() {
  kill('corr');
  const pairs = [];
  SEASONS.forEach(s => {
    if (s.id === '19/20' || s.id === '20/21') return;
    const totals = seasonTotals(s.id);
    if (!totals) return;
    const tour = getTourismForSeason(s.id);
    if (tour.total > 0) pairs.push({ x: totals.valley.avgSnow, y: tour.total, id: s.id });
  });

  if (pairs.length < 2) return;

  charts.corr = new Chart(document.getElementById('corrChart'), {
    type: 'scatter',
    data: {
      datasets: [{
        label: 'Saison',
        data: pairs,
        backgroundColor: pairs.map(p => p.id === activeSeason ? C.valley : 'rgba(79,195,247,0.5)'),
        pointRadius: pairs.map(p => p.id === activeSeason ? 8 : 6),
        pointHoverRadius: 10,
      }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: 'Ã˜ SchneehÃ¶he Tal (cm)' } },
        y: { title: { display: true, text: 'NÃ¤chtigungen' }, beginAtZero: true }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${pairs[ctx.dataIndex].id}: ${pairs[ctx.dataIndex].x.toFixed(0)}cm / ${fmtNum(pairs[ctx.dataIndex].y)}`
          }
        }
      }
    }
  });
}

// Sun vs Overnights
function renderSunCorr() {
  kill('sunCorr');
  const pairs = [];
  SEASONS.forEach(s => {
    if (s.id === '19/20' || s.id === '20/21') return;
    const totals = seasonTotals(s.id);
    if (!totals) return;
    const tour = getTourismForSeason(s.id);
    if (tour.total > 0) pairs.push({ x: totals.valley.totalSun, y: tour.total, id: s.id });
  });

  if (pairs.length < 2) return;

  charts.sunCorr = new Chart(document.getElementById('sunCorrChart'), {
    type: 'scatter',
    data: {
      datasets: [{
        label: 'Saison',
        data: pairs,
        backgroundColor: pairs.map(p => p.id === activeSeason ? C.sun : 'rgba(255,213,79,0.5)'),
        pointRadius: pairs.map(p => p.id === activeSeason ? 8 : 6),
      }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: {
        x: { title: { display: true, text: 'Sonnenstunden' } },
        y: { title: { display: true, text: 'NÃ¤chtigungen' }, beginAtZero: true }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${pairs[ctx.dataIndex].id}: ${pairs[ctx.dataIndex].x.toFixed(0)}h / ${fmtNum(pairs[ctx.dataIndex].y)}`
          }
        }
      }
    }
  });
}

// Snowfall bars
function renderSnowfall() {
  kill('snowfall');
  const w = weatherData[activeSeason];
  if (!w) return;
  const vm = monthlyWeather(w.valley);
  const mm = monthlyWeather(w.mountain);

  charts.snowfall = new Chart(document.getElementById('snowfallChart'), {
    type: 'bar',
    data: {
      labels: MONTH_LABELS,
      datasets: [
        { label: 'Tal', data: WINTER_MONTHS.map(m => vm[m]?.totalSnowfall || 0), backgroundColor: C.valley, borderRadius: 5 },
        { label: 'Berg', data: WINTER_MONTHS.map(m => mm[m]?.totalSnowfall || 0), backgroundColor: C.mtn, borderRadius: 5 },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: { y: { title: { display: true, text: 'Neuschnee (cm)' }, beginAtZero: true } },
      plugins: { legend: { position: 'top' } }
    }
  });
}

// Temperature
function renderTemp() {
  kill('temp');
  const w = weatherData[activeSeason];
  if (!w) return;
  const vm = monthlyWeather(w.valley);
  const mm = monthlyWeather(w.mountain);

  charts.temp = new Chart(document.getElementById('tempChart'), {
    type: 'line',
    data: {
      labels: MONTH_LABELS,
      datasets: [
        { label: 'Tal Max', data: WINTER_MONTHS.map(m => vm[m]?.avgTMax || 0), borderColor: C.valley, borderWidth: 2, pointRadius: 4, tension: 0.3 },
        { label: 'Tal Min', data: WINTER_MONTHS.map(m => vm[m]?.avgTMin || 0), borderColor: C.valley, borderWidth: 2, borderDash: [5,4], pointRadius: 4, tension: 0.3 },
        { label: 'Berg Max', data: WINTER_MONTHS.map(m => mm[m]?.avgTMax || 0), borderColor: C.mtn, borderWidth: 2, pointRadius: 4, tension: 0.3 },
        { label: 'Berg Min', data: WINTER_MONTHS.map(m => mm[m]?.avgTMin || 0), borderColor: C.mtn, borderWidth: 2, borderDash: [5,4], pointRadius: 4, tension: 0.3 },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      scales: { y: { title: { display: true, text: 'Â°C' } } },
      plugins: { legend: { position: 'top' } }
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEASON COMPARISON TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderSeasonTable() {
  const rows = SEASONS.map(s => {
    const totals = seasonTotals(s.id);
    if (!totals) return null;
    const tour = getTourismForSeason(s.id);
    return { id: s.id, vt: totals.valley, mt: totals.mountain, nights: tour.total };
  }).filter(Boolean);

  if (!rows.length) return;

  const maxSnow = Math.max(...rows.map(r => r.mt.maxSnow));
  const maxSun = Math.max(...rows.map(r => r.vt.totalSun));
  const maxNights = Math.max(...rows.map(r => r.nights));

  let html = `<table class="stable">
    <thead><tr>
      <th>Saison</th>
      <th>ğŸ›ï¸ NÃ¤chtigungen</th><th style="width:90px"></th>
      <th>â„ï¸ Ã˜ Schnee Tal</th>
      <th>â›°ï¸ Max Berg</th><th style="width:80px"></th>
      <th>ğŸŒ¨ï¸ Neuschnee</th>
      <th>â˜€ï¸ Sonne</th><th style="width:70px"></th>
      <th>ğŸŒ¡ï¸ Ã˜ Temp</th>
    </tr></thead><tbody>`;

  rows.forEach(r => {
    const snowPct = maxSnow > 0 ? (r.mt.maxSnow / maxSnow * 100).toFixed(0) : 0;
    const sunPct = maxSun > 0 ? (r.vt.totalSun / maxSun * 100).toFixed(0) : 0;
    const nightPct = maxNights > 0 ? (r.nights / maxNights * 100).toFixed(0) : 0;
    const isCovid = r.id === '19/20' || r.id === '20/21';

    html += `<tr${r.id === activeSeason ? ' style="background:rgba(79,195,247,0.06)"' : ''}>
      <td><strong>${r.id}</strong>${isCovid ? ' <span style="color:var(--warn);font-size:0.7rem">COVID</span>' : ''}</td>
      <td class="num">${fmtNum(r.nights)}</td>
      <td class="bar-cell"><div class="mini-bar bar-nights" style="width:${nightPct}%"></div></td>
      <td class="num">${r.vt.avgSnow.toFixed(0)} cm</td>
      <td class="num">${r.mt.maxSnow.toFixed(0)} cm</td>
      <td class="bar-cell"><div class="mini-bar bar-snow" style="width:${snowPct}%"></div></td>
      <td class="num">${r.mt.totalSF.toFixed(0)} cm</td>
      <td class="num">${r.vt.totalSun.toFixed(0)} h</td>
      <td class="bar-cell"><div class="mini-bar bar-sun" style="width:${sunPct}%"></div></td>
      <td class="num" style="color:${r.vt.avgTemp > 0 ? 'var(--warn)' : 'var(--valley)'}">${r.vt.avgTemp.toFixed(1)}Â°C</td>
    </tr>`;
  });

  html += '</tbody></table>';
  document.getElementById('seasonTable').innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORRELATION ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function computeCorrelation() {
  const pairs = [];
  SEASONS.forEach(s => {
    if (s.id === '19/20' || s.id === '20/21') return;
    const totals = seasonTotals(s.id);
    if (!totals) return;
    const tour = getTourismForSeason(s.id);
    if (tour.total > 0) pairs.push({ snow: totals.valley.avgSnow, nights: tour.total, id: s.id });
  });

  if (pairs.length < 3) return null;

  const n = pairs.length;
  const avgX = pairs.reduce((s,p) => s + p.snow, 0) / n;
  const avgY = pairs.reduce((s,p) => s + p.nights, 0) / n;
  let num = 0, denX = 0, denY = 0;
  pairs.forEach(p => {
    const dx = p.snow - avgX, dy = p.nights - avgY;
    num += dx * dy; denX += dx * dx; denY += dy * dy;
  });
  const r = denX && denY ? num / Math.sqrt(denX * denY) : 0;
  return { r, pairs };
}

function renderCorrSummary() {
  const result = computeCorrelation();
  const el = document.getElementById('corrSummary');

  if (!result || result.pairs.length < 3) {
    el.innerHTML = '<div class="card-h"><span class="card-t">Korrelationsanalyse</span></div><p style="color:var(--text-muted);font-size:0.9rem;">Nicht genug Daten (COVID-Saisons ausgeschlossen)</p>';
    return;
  }

  const r = result.r;
  const rAbs = Math.abs(r);
  let strength, color;
  if (rAbs > 0.7) { strength = 'starke'; color = 'var(--tourism)'; }
  else if (rAbs > 0.4) { strength = 'moderate'; color = 'var(--sun)'; }
  else { strength = 'schwache'; color = 'var(--text-muted)'; }

  const direction = r > 0 ? 'positive' : 'negative';

  el.innerHTML = `
    <div class="card-h">
      <span class="card-t">ğŸ“Š Korrelationsanalyse Â· SchneehÃ¶he â†” NÃ¤chtigungen</span>
      <span class="badge b-t">COVID-Saisons ausgenommen</span>
    </div>
    <div class="corr-box">
      <div class="corr-r" style="color:${color}">r = ${r.toFixed(2)}</div>
      <div class="corr-text">
        Es besteht eine <strong>${strength} ${direction} Korrelation</strong> zwischen der durchschnittlichen SchneehÃ¶he im Tal
        und den Winter-NÃ¤chtigungen (ohne COVID-Saisons 19/20 & 20/21).
        ${r > 0.4 ? '<br>âœ <strong>Mehr Schnee â†’ tendenziell mehr GÃ¤ste.</strong> Die Schneesicherheit bleibt ein wichtiger Faktor fÃ¼r den Wintertourismus im Kleinwalsertal.'
          : '<br>âœ Der Zusammenhang ist allerdings nicht stark genug um SchneehÃ¶he als alleinigen Treiber fÃ¼r Buchungen zu sehen. Andere Faktoren (Feiertage, Wirtschaft, Marketing) spielen eine erhebliche Rolle.'}
        <br><span style="font-size:0.78rem;color:var(--text-dim)">Basierend auf ${result.pairs.length} Saisonen Â· Pearson-Korrelationskoeffizient Â·
        Schneedaten: ${geoSphereAvailable ? 'GeoSphere SNOWGRID 1km' : 'Open-Meteo ERA5'} Â·
        NÃ¤chtigungen: Statistik Austria</span>
      </div>
    </div>
  `;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
  if (!weatherData[activeSeason]) return;
  renderKPIs();
  renderDualChart();
  renderSnowTimeline();
  renderCorrScatter();
  renderSunCorr();
  renderSnowfall();
  renderTemp();
  renderSeasonTable();
  renderCorrSummary();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function init() {
  log('Dashboard-Start: Kleinwalsertal Wetter & Tourismus', 'info');
  log(`Datenquellen: GeoSphere SNOWGRID (Schnee) + Open-Meteo (Wetter) + Statistik Austria (Tourismus)`, 'info');

  buildTabs();
  
  try {
    await loadAll();
  } catch (e) {
    log(`Kritischer Fehler beim Laden: ${e.message}`, 'err');
  }

  if (!Object.keys(weatherData).length) {
    document.getElementById('kpis').innerHTML = `
      <div style="color:var(--warn);padding:2rem;text-align:center;grid-column:1/-1;">
        <div style="font-size:1.5rem;margin-bottom:0.5rem;">âš ï¸</div>
        <div style="font-size:1rem;margin-bottom:0.5rem;">Wetterdaten konnten nicht geladen werden</div>
        <div style="font-size:0.8rem;color:var(--text-muted);">
          Bitte Netzwerkverbindung prÃ¼fen. Die APIs (Open-Meteo, GeoSphere) mÃ¼ssen erreichbar sein.
          <br><button onclick="location.reload()" style="margin-top:0.8rem;padding:8px 16px;border-radius:8px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer;font-family:inherit;">ğŸ”„ Erneut versuchen</button>
        </div>
      </div>`;
    return;
  }

  if (!weatherData[activeSeason]) activeSeason = Object.keys(weatherData).pop();

  // Log summary
  log(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`, 'info');
  log(`SchneehÃ¶he-Quelle: ${geoSphereAvailable ? 'âœ“ GeoSphere SNOWGRID (1km, modelliert)' : 'âš  Open-Meteo ERA5 Fallback / Simulation'}`, geoSphereAvailable ? 'ok' : 'warn');
  log(`Wetterdaten: âœ“ Open-Meteo Archive API (ERA5-Land)`, 'ok');
  log(`Tourismus: Statistik Austria â€“ BITTE VERIFIZIEREN (manuelle Daten)`, 'warn');
  log(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`, 'info');

  render();
}

init();
</script>
</body>
</html>
